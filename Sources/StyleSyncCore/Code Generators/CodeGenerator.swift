//
//  CodeGenerator.swift
//  StyleSync
//
//  Created by Dylan Lewis on 12/08/2017.
//  Copyright Â© 2017 Dylan Lewis. All rights reserved.
//

import Foundation
import Files

/// A `String` of a code template, where replacable ranges are denoted as
/// `<replacableDeclaration>` and `</replacableDeclaration>`, and replaceable
/// elements are denoted as `<#=replaceableElement#>`
public typealias Template = String

public struct CodeGenerator {
	// MARK: - Stored properties
	
	private let template: Template
	private var templateCodeLines: [String]
	public var fileExtension: FileType
	public var fileName: String?

	// MARK: - Initializer
	
	/// Creates a `CodeGenerator` with a given template and an array of groups
	/// of elements to replace. Each element of each group will have code
	/// generated for it, using the provided template.
	///
	/// - Parameter templateFile: A File containing a code template.
	/// - Throws: An error if the file extension cannot be found.
	public init(templateFile: File) throws {
		try templateFile.validateAsTemplateFile()
		self.template = try templateFile.readAsString()
		self.fileExtension = try templateFile.templateFileExtension()
		self.fileName = templateFile.templateFileName
		self.templateCodeLines = template.components(separatedBy: "\n")
	}
	
	/// Creates a `CodeGenerator` with a given template and an array of groups
	/// of elements to replace. Each element of each group will have code
	/// generated for it, using the provided template.
	///
	/// - Parameters:
	///   - template: A code template.
	///   - fileExtension: The generated file's extension.
	///   - fileName: The generated file's name.
	public init(template: Template, fileExtension: String, fileName: String? = nil) {
		self.template = template
		self.fileExtension = fileExtension
		self.templateCodeLines = template.components(separatedBy: "\n")
	}
	
	// MARK: - Code Generation
	
	/// Code generated by replacing the `codeTemplateReplacables` in the
	/// `template`.
	///
	/// - Parameters:
	///   - codeTemplateReplacables: An array of groups of elements to replace.
	///								 Each element of each group will have code
	///								 generated for it, using the provided
	///								 template.
	///   - version: The version of the style guide
	/// - Returns: The generated code of the template replacables and the
	///			   template.
	public func generatedCode(for codeTemplateReplacables: [[CodeTemplateReplacable]], version: Version? = nil) -> String {
		let allCodeTemplateReplaceables: [[CodeTemplateReplacable]]
		if let version = version {
			let headerLines = """
			Style Guide v\(version.stringRepresentation)

			Generated by stylesync
			https://github.com/dylanslewis/stylesync
			"""
			let generatedDocumentHeaderLines = headerLines.components(separatedBy: "\n").map(HeaderLine.init)
			allCodeTemplateReplaceables = [generatedDocumentHeaderLines] + codeTemplateReplacables
		} else {
			allCodeTemplateReplaceables = codeTemplateReplacables
		}
		
		// Iterate over each group of `codeTemplateReplacables` and replace the
		// placeholders.
		var codeLines = templateCodeLines
		allCodeTemplateReplaceables
			.forEach({ codeLines = codeLines.replacingCodePlaceholders(usingReplacementItems: $0) })
		codeLines.validateCodeLines()
		return codeLines.joined(separator: "\n")
	}
	
	public func generatedCode(for codeTemplateReplaceable: CodeTemplateReplacable) -> String {
		return generatedCode(for: [[codeTemplateReplaceable]])
	}
}

// MARK: - HeaderLine

private extension CodeGenerator {
	/// A line of text to be shown in the header of the generated file.
	struct HeaderLine: CodeTemplateReplacable {
		let declarationName: String = "generatedFileHeader"
		let headerLine: String
		
		var replacementDictionary: [String: String] {
			return ["headerLine": headerLine]
		}
	}
}

// MARK: - Error

extension CodeGenerator {
	enum Error: Swift.Error, CustomStringConvertible {
		case noFileExtensionFound
		
		/// A string describing the error.
		public var description: String {
			switch self {
			case .noFileExtensionFound:
				let fileExtensionReference = "fileExtension".metadataPlaceholderReference
				return "Failed to find file extension in template. Make sure to include \(fileExtensionReference) in your template file.\nSee \(GitHubLink.templateReadme) for more information on how to create a template."
			}
		}
	}
}

// MARK: - Helpers

private extension File {
	var templateFileName: String? {
		guard let fileExtensionAndTemplate = self.fileExtensionAndTemplate else {
			return nil
		}
		let templateFileNameSubstring = nameExcludingExtension
			.replacingOccurrences(of: fileExtensionAndTemplate, with: "")
			.dropLast()
		return String(templateFileNameSubstring)
	}
	
	func templateFileExtension() throws -> String {
		guard let fileExtensionAndTemplate = self.fileExtensionAndTemplate else {
			throw CodeGenerator.Error.noFileExtensionFound
		}
		return fileExtensionAndTemplate
			.replacingOccurrences(of: "-template", with: "")
	}
	
	private var fileExtensionAndTemplate: String? {
		let fileNameComponents = nameExcludingExtension.components(separatedBy: ".")
		return fileNameComponents.last
	}
}

private extension Array where Iterator.Element == String {
	/// Replaces all placeholders in each of the array's code lines, by looking
	/// up the corresponding value in the `replacementDictionary`.
	///
	/// - Parameters:
	///   - replacementDictionary: The dictionary used to replace placeholders
	///		with values
	///   - isDeprecated: Whether the style is deprecated
	/// - Returns: The original array with the placeholders replaced with
	///		values.
	func replacingCodePlaceholders(usingReplacementDictionary replacementDictionary: [String: String], isDeprecated: Bool) -> [String] {
		let deprecatedKey = "deprecated"
		let deprecatedReference = "\(deprecatedKey)=\(isDeprecated)".conditionalCodePlaceholderReference

		return map({ line -> String in
			var codeLineWithReplacedPlaceholders = line
			replacementDictionary.forEach({ (arg) in
				let (replacementKey, replacementValue) = arg
				codeLineWithReplacedPlaceholders = codeLineWithReplacedPlaceholders
					.replacingOccurrences(of: replacementKey.codePlaceholderReference, with: replacementValue)
			})
			return codeLineWithReplacedPlaceholders
		}).flatMap({ line -> String? in
			switch line.contains(deprecatedReference) {
			case true:
				// Condition is matched, remove the reference from the line.
				return line.replacingOccurrences(of: deprecatedReference, with: "")
			case false where line.contains(deprecatedKey):
				// It contains the key, but the condition is not matched. Remove
				// the line.
				return nil
			case false:
				return line
			}
		})
	}
	
	/// Replaces code placeholders in an array of code lines by finding the
	/// start declaration and end declaration, getting the replacement template
	/// and then replacing the placeholders in that template using each of the
	/// replacement items. The original code placeholders are then removed from
	/// the code lines.
	///
	/// - Parameters:
	///   - replacementItems: The items used to replace the code placeholders.
	///   - codeLines: The code lines that contain the code placeholders
	/// - Returns: The code lines with replaced code placeholders.
	func replacingCodePlaceholders(usingReplacementItems replacementItems: [CodeTemplateReplacable]) -> [String] {
		guard let firstReplacementItem = replacementItems.first else {
			ErrorManager.log(warning: "Unable to find element type during code replacement")
			return self
		}
		
		let declarationName = firstReplacementItem.declarationName
		
		var codeLinesWithReplacement = self
		var containsDeclarationForType = true
		repeat {
			guard
				let declarationStartIndex = codeLinesWithReplacement.index(where: { $0.contains(declarationName.declarationStartReference) }),
				let declarationEndIndex = codeLinesWithReplacement.index(where: { $0.contains(declarationName.declarationEndReference) })
			else {
				containsDeclarationForType = false
				continue
			}
			
			// Extract the template for the given replacement item type.
			let replacementItemTemplate = Array(codeLinesWithReplacement[declarationStartIndex.advanced(by: 1)..<declarationEndIndex])
			let codeLinesWithReplacedPlaceholders = replacementItems
				.map({ return replacementItemTemplate
					.replacingCodePlaceholders(usingReplacementDictionary: $0.replacementDictionary, isDeprecated: $0.isDeprecated) })
				.flatMap({ $0 })
			codeLinesWithReplacement.replaceSubrange(declarationStartIndex...declarationEndIndex, with: codeLinesWithReplacedPlaceholders)
		} while containsDeclarationForType == true
		
		return codeLinesWithReplacement
	}
	
	/// Checks that there are no placeholders remaining in the code lines. If
	/// any are found, a warning is printed to the console.
	func validateCodeLines() {
		enumerated().forEach { arg in
			let (offset, element) = arg
			if element.contains("<#") {
				ErrorManager.log(warning: "Unreplaced placeholder at line \(offset):\n" + element + "\n")
			}
		}
	}
}

private extension String {
	private enum ReplaceableReference {
		static let start: String = "<#"
		static let end: String = "#>"
	}
	
	private func replaceableReference(withSymbol symbol: String) -> String {
		return ReplaceableReference.start + symbol + self + ReplaceableReference.end
	}
	
	/// Wraps the current string in a code placeholder reference.
	var codePlaceholderReference: String {
		return replaceableReference(withSymbol: "=")
	}
	
	var conditionalCodePlaceholderReference: String {
		return replaceableReference(withSymbol: "?")
	}
	
	var codePlaceholderEndReference: String {
		return replaceableReference(withSymbol: "/")
	}
	
	var metadataPlaceholderReference: String {
		return replaceableReference(withSymbol: "@")
	}
	
	/// Wraps the current string in a declaration start reference.
	var declarationStartReference: String {
		return "<" + self + ">"
	}
	
	/// Wraps the current string in a declaration end reference.
	var declarationEndReference: String {
		return "</" + self + ">"
	}
}
